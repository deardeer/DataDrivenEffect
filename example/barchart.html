<!DOCTYPE html>
<meta charset="utf-8">
<style>

.bar {
  fill: steelblue;
}

.bar:hover {
  fill: brown;
}

.axis--x path {
  display: none;
}

</style>
<svg width="600" height="400"></svg>
<script src="https://d3js.org/d3.v4.min.js"></script>
<script type="text/javascript" src="draw/fisheye.js"></script>
<script>

 var colorlist = ["#3182bd", "#9ecae1", 
  "#e6550d", "#fdae6b", 
  "#31a354", "#a1d99b", 
  "#756bb1", "#bcbddc", 
  "#636363", "#bdbdbd"]

var animate = true;
var svg = d3.select("svg"),
    margin = {top: 20, right: 20, bottom: 30, left: 40},
    width = +svg.attr("width") - margin.left - margin.right,
    height = +svg.attr("height") - margin.top - margin.bottom;

var x = d3.scaleBand().rangeRound([0, width]).padding(0.3),
    y = d3.scaleLinear().rangeRound([height, 0]);

var g = svg.append("g")
    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

d3.tsv("barchart.tsv", function(d) {
  d.frequency = +d.frequency;
  return d;
}, function(error, data) {
  if (error) throw error;

  x.domain(data.map(function(d) { return d.letter; }));
  y.domain([0, d3.max(data, function(d) { return d.frequency; })]);

  g.append("g")
      .attr("class", "axis axis--x")
      .attr("transform", "translate(0," + height + ")")
      .call(d3.axisBottom(x));

  g.append("g")
      .attr("class", "axis axis--y")
      .call(d3.axisLeft(y).ticks(10, "%"))
    .append("text")
      .attr("transform", "rotate(-90)")
      .attr("y", 6)
      .attr("dy", "0.71em")
      .attr("text-anchor", "end")
      .text("Frequency");


  var lineFunction = d3.line()
            .x(function(d){return d.x})
            .y(function(d){return d.y})

  var liRect = []
  var mapGroupVLines = {}
  var mapGroupHLines = {};
  var idIndex = 0;
  svg.selectAll(".bar")
    .data(data)
    .enter().append('path')
      .attr("class", "bar")       
       .attr('lineData', function(d){  
        var lineData = [];      
        var left = margin.left + x(d.letter), top = margin.top + y(d.frequency)
        var barwidth = x.bandwidth()
        var barheight = height - y(d.frequency)
        var stepNum = 10;        
        for(var p = 0; p <= stepNum; p ++){
          lineData.push({'x':left + p * barwidth/stepNum, 'y': top})
        }
        for(var p = 0; p <= stepNum; p ++){
          lineData.push({'x':left + barwidth, 'y': top + p * barheight/stepNum})
        }
        for(var p = 0; p <= stepNum; p ++){
          lineData.push({'x':left + (stepNum - p) * barwidth/stepNum, 'y': top + barheight})
        }
        for(var p = 0; p <= stepNum; p ++){
          lineData.push({'x':left, 'y': top +  + (stepNum - p) * barheight/stepNum})
        }

        for(var p = 0; p <= stepNum; p++){
          var VLine = [];
          for(var h = 0; h < Math.floor(barheight/5); h ++){
            VLine.push({'x': left + (p) * barwidth/stepNum, 'y': top + h * 5})
          }
          if(mapGroupVLines[idIndex] == undefined)
            mapGroupVLines[idIndex] = [VLine];
          else
            mapGroupVLines[idIndex].push(VLine);
        }

        for(var h = 0; h < Math.floor(barheight/5); h ++){
          var HLine = [];
          for(var p = 0; p < Math.floor(barwidth/5); p ++){          
            HLine.push({'x': left + (p) * 5, 'y': top + h * 5})
          }
          if(mapGroupHLines[idIndex] == undefined)
            mapGroupHLines[idIndex] = [HLine];
          else
            mapGroupHLines[idIndex].push(HLine);
        }

          var rect = {
            'x': x(d.letter) + margin.left,
            'y': y(d.frequency) + margin.top,
            'width': x.bandwidth(),
            'height': height - y(d.frequency)};
          liRect.push(rect);
          d3.select(this).attr('id', 'rect-' + idIndex);
          idIndex += 1
          // console.log(' liData ', lineData.join(','))
          return JSON.stringify(lineData);
       })
       .attr('d', function(d){
        var lineData = JSON.parse(d3.select(this).attr('lineData'))
        // console.log(" line data " , lineData);
        return lineFunction(lineData);
       })    
       .style('fill', function(d){
        return colorlist[+d3.select(this).attr('id').split('-')[1]]
       })
  
  for(var iGroup in mapGroupVLines){
    var liVLine = mapGroupVLines[iGroup]
    svg.selectAll('.vline_' + iGroup)
       .data(liVLine)
       .enter()
       .append('path')
       .attr('class', 'vline vline_' + iGroup)
       .attr('lineData', function(d){
        // console.log(' liVLine ', d);
        return JSON.stringify(d)
       })
       .attr('d', function(d){
        return lineFunction(d);
       })
       .style('stroke', 'white')
       .style('fill', 'none')
    // console.log(" iGroup ", iGroup, liVLine)
  }

  for(var iGroup in mapGroupHLines){
    var liHLine = mapGroupHLines[iGroup]
    svg.selectAll('.hline_' + iGroup)
       .data(liHLine)
       .enter()
       .append('path')
       .attr('class', 'hline hline_' + iGroup)
       .attr('lineData', function(d){
        // console.log(' liVLine ', d);
        return JSON.stringify(d)
       })
       .attr('d', function(d){
        return lineFunction(d);
       })
       .style('stroke', 'white')
       .style('fill', 'none')
    // console.log(" iGroup ", iGroup, liVLine)
  }

   var shiftX = 20
  
   var mapFishEye = {};
   var mapRadius = {
    0: 30,
    1: 40,
    2: 10,
    3: 51, 
    4: 20,
    5: 32,
    6: 10,
    7: 32
   }
   for(var i = 0; i < liRect.length; i ++){
      var testRect = liRect[i];
      var fishMaxRadius = testRect['width'] * 0.5 + shiftX
      var fisheye = d3.fisheye()
                  .radius(fishMaxRadius);
      fisheye.center([testRect['x'] - shiftX, testRect['y'] - shiftX]);
      mapFishEye[i] = {
        'fisheye': fisheye,
        // 'maxradius': mapRadius[i]
      }
   }

   // console.log(' testRect ', testRect);

   // svg.append('circle')
   // .attr('class', 'fisheye')
   // .attr('cx', testRect['x'])
   // .attr('cy', testRect['y'])
   // .attr('r', fishMaxRadius)
   // .style('fill', 'none')
   // .style("stroke", 'black')

   if(animate){
    var timer = 0
    var increase = true;
    var step = 0.1
    var interval = setInterval(function(){
      // console.log(' radius ', testRect['width'] * (0.5 + timer * 0.1));
      // console.log(0.5 + timer * step)

      for(var groupId in mapFishEye){
        var fisheye = mapFishEye[groupId]['fisheye']
        var maxradius = mapRadius[groupId]
        // console.log(' maxradius ', maxradius, groupId)
        fisheye.radius(maxradius * (0.5 + timer * step));

        var liPoint = JSON.parse(d3.select('#rect-' + groupId).attr('lineData'));
        var liNewPos = [];
        for(var index in liPoint){
          var point = liPoint[index]
          var newpoint = fisheye([point['x'], point['y']]);
          // console.log('point ', point, newpoint)
          liNewPos.push({
            'x': newpoint[0],
            'y': newpoint[1]
          })        
        }
        d3.selectAll('.vline_' + groupId)
           .each(function(){
            var liLinePos = JSON.parse(d3.select(this).attr('lineData'));
            var liVLineNewPos = [];
            for(var index in liLinePos){
              var point = liLinePos[index]
              var newpoint = fisheye([point['x'], point['y']]);
              // console.log('point ', point, newpoint)
              liVLineNewPos.push({
                'x': newpoint[0],
                'y': newpoint[1]
              })        
            }
            d3.select(this)        
              .attr('d', lineFunction(liVLineNewPos));
         })
        d3.selectAll('.hline_' + groupId)
           .each(function(){
            var liLinePos = JSON.parse(d3.select(this).attr('lineData'));
            var liVLineNewPos = [];
            for(var index in liLinePos){
              var point = liLinePos[index]
              var newpoint = fisheye([point['x'], point['y']]);
              // console.log('point ', point, newpoint)
              liVLineNewPos.push({
                'x': newpoint[0],
                'y': newpoint[1]
              })        
            }
            d3.select(this)        
              .attr('d', lineFunction(liVLineNewPos));
         })             

        d3.select('#rect-' + groupId)
          .attr('d', lineFunction(liNewPos));
      }      

      // if(timer == 6)
        // clearInterval(interval)

      if(timer >= 10){ 
        increase = false;
      }
      if(timer == 0)
        increase = true;

      timer += (increase? 1: -1);
    }, 150)
   }
});

</script>